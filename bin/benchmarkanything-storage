#! /usr/bin/perl
# PODNAME: benchmarkanything-storage
# ABSTRACT: BenchmarkAnything storage cmdline tool

use 5.008;
use strict;
use warnings;

use App::Rad;

######################################################################
#
# App::Rad interface
#
######################################################################

App::Rad->run();

sub setup
{
        my $c = shift;
        $c->unregister_command("help");
        $c->register_commands("help", "search", "add", "createdb", "listnames", "getpoint");
}

sub help
{
        my ($c) = @_;

        return qq{benchmarkanything-storage [-o|--outtype <TYPE>]
                          [-i|--intype <TYPE>]
                          [-c|--cfgfile <FILE>]
                          [-d|--debug]
                          [-v|--verbose]
                          [-p|--pattern <PATTERN>]
                          [--id <VALUE_ID>]
                          [--really <DSN>]
                          [search|add|createdb|listnames|getpoint] <DATAFILE>

        -i
        --intype         - input format
                           [json(default), yaml, dumper]
        -o
        --outtype        - output format
                           [json(default), yaml, dumper]
        -c
        --cfgfile        - config file for storage backend

        -p
        --pattern        - pattern for 'listnames' command (using LIKE)

        --id             - search id for 'getpoint' command

        -b
        --backend        - backend
                           [tapper(default), http]

        --debug          - Pass through debug option to used modules

        --verbose        - print what's going on

        --really         - used for 'createdb' command.
                           Avoids the 'Are you sure?' question. You need to
                           provide the DSN from config that createdb would use,
                           to avoid painful mistakes.

        <DATAFILE>       - input data file ("-" for STDIN)
                           Content depends on the sub command:
                           + for 'search' it is a search query
                           + for 'add' it is BenchmarkAnything data
                           + for 'createdb' no input data is used
};
}

sub _getopt
{
        my ($c) = @_;

        $c->getopt( "cfgfile|c=s",
                    "backend|b=s",
                    "outtype|o=s",
                    "intype|i=s",
                    "pattern|p=s",
                    "id=s",
                    "debug|d",
                    "verbose|v",
                    "really=s",
                  )
         or help() and return undef;

        require BenchmarkAnything::Storage::Frontend::Lib;

        my $opt = $c->options;
        $c->{_balib}    = BenchmarkAnything::Storage::Frontend::Lib->new(cfgfile => $opt->{cfgfile},
                                                                         backend => $opt->{backend} || 'tapper',
                                                                         really  => $opt->{really},
                                                                        );
        $c->{_file}     = $c->argv->[0]    || '-';
}

sub search :Help(search BenchmarkAnything data)
{
        my ($c) = @_;

        _getopt($c);
        _search($c);
}

sub add :Help(add one or more BenchmarkAnything entries)
{
        my ($c) = @_;

        _getopt($c);
        _add($c);
}

sub createdb :Help(drop and create tables in the backend store)
{
        my ($c) = @_;

        _getopt($c);
        _createdb($c);
}

sub listnames :Help(list existing metric names)
{
        my ($c) = @_;

        _getopt($c);
        _listnames($c);
}

sub getpoint :Help(get benchmark point with all existing fields)
{
        my ($c) = @_;

        _getopt($c);
        _getpoint($c);
}

######################################################################
#
# Implementation
#
######################################################################

=head2 _read_in

This function reads in a data structure. The meaning of the data
depends on the sub command: for C<search> it is a search query, for
C<add> it is an array of BenchmarkAnything data points.

=cut

sub _read_in
{
        my ($c) = @_;

        my $opt = $c->options;

        my $file = $c->{_file};
        my $intype  = $opt->{intype}  || 'json';
        my $data;
        my $filecontent;
        {
                local $/;
                if ($file eq '-') {
                        $filecontent = <STDIN>;
                }
                else
                {
                        open (my $FH, "<", $file) or die "benchmarkanything-storage: cannot open input file $file.\n";
                        $filecontent = <$FH>;
                        close $FH;
                }
        }

        if (not defined $filecontent or $filecontent !~ /[^\s\t\r\n]/ms) {
                die "benchmarkanything-storage: no meaningful input to read.\n";
        }

        if ($intype eq "yaml") {
                require YAML::Any;
                $data = [YAML::Any::Load($filecontent)];
        }
        elsif ($intype eq "json") {
                require JSON;
                $data = JSON::decode_json($filecontent);
        }
        elsif ($intype eq "dumper") {
                eval '$data = my '.$filecontent;
        }
        else
        {
                die "benchmarkanything-storage: unrecognized input format: $intype.\n";
        }
        return $data;
}

=head2 _write_out

This function writes a data structure in requested output format.

=cut

sub _write_out
{
        my ($c, $benchmarkanythingdata) = @_;

        my $opt = $c->options;

        my $output = "";
        my $outtype = $opt->{outtype} || 'json';
        if ($outtype eq "yaml")
        {
                require YAML::Any;
                $output .= YAML::Any::Dump($benchmarkanythingdata);
        }
        elsif ($outtype eq "json")
        {
                eval "use JSON -convert_blessed_universally";
                my $json = JSON->new->allow_nonref->pretty->allow_blessed->convert_blessed;
                $output .= $json->encode($benchmarkanythingdata);
        }
        elsif ($outtype eq "ini") {
                require Config::INI::Serializer;
                my $ini = Config::INI::Serializer->new;
                $output .= $ini->serialize($benchmarkanythingdata);
        }
        elsif ($outtype eq "dumper")
        {
                require Data::Dumper;
                $output .= Data::Dumper::Dumper($benchmarkanythingdata);
        }
        elsif ($outtype eq "xml")
        {
                require XML::Simple;
                my $xs = new XML::Simple;
                $output .= $xs->XMLout($benchmarkanythingdata, AttrIndent => 1, KeepRoot => 1);
        }
        elsif ($outtype eq "flat") {
                $output .= _format_flat( $c, $benchmarkanythingdata );
        }
        else
        {
                die "benchmarkanything-storage: unrecognized output format: $outtype.";
        }
        return $output;
}

sub _listnames
{
        my ($c) = @_;

        $c->{_balib}->connect;
        my $result = $c->{_balib}->listnames ($c->options->{pattern});
        _write_out($c, $result);
}

sub _getpoint
{
        my ($c) = @_;

        if ($c->{_balib}{backend} eq "tapper")
        {
                require DBI;
                require Tapper::Benchmark;

                # connect
                my $dbh              = $c->{_balib}->connect->{dbh};
                my $tapper_benchmark = Tapper::Benchmark->new({dbh => $dbh, debug => $c->options->{debug} });

                # query
                my $id = $c->options->{id};
                die "benchmarkanything-storage: please provide a benchmark value id using --id'\n"
                    unless $id;
                my $point = $tapper_benchmark->get_single_benchmark_point($id);

                # output
                _write_out($c, $point);
        }
        else
        {
                die "benchmarkanything-storage: backend '.$c->{_balib}{backend}.' not yet implemented, available backends are: 'tapper'\n";
        }
}

sub _search
{
        my ($c) = @_;

        my $query = _read_in($c);
        $c->{_balib}->connect;
        my $result = $c->{_balib}->search($query);
        _write_out($c, $result);
}

sub _add
{
        my ($c) = @_;

        my $data = _read_in($c);

        # --- validate ---
        if (not $data)
        {
                die "benchmarkanything-storage: no input data provided.\n";
        }

        require BenchmarkAnything::Schema;
        print "Verify schema...\n" if $c->options->{verbose};
        if (not my $result = BenchmarkAnything::Schema::valid_json_schema($data))
        {
                die "benchmarkanything-storage: add: invalid input: ".join("; ", $result->errors)."\n";
        }


        # --- add to storage ---

        if ($c->{_balib}{backend} eq "tapper")
        {
                require Tapper::Benchmark;

                # connect
                print "Connect db...\n" if $c->options->{verbose};
                my $dbh              = $c->{_balib}->connect->{dbh};
                my $tapper_benchmark = Tapper::Benchmark->new({dbh => $dbh, debug => $c->options->{debug} });

                # add data
                print "Add data...\n" if $c->options->{verbose};
                foreach my $chunk (@{$data->{BenchmarkAnythingData}}) { # ensure order, because T::Benchmark optimizes multi-chunk entries
                    my $success = $tapper_benchmark->add_multi_benchmark([$chunk]);
                    if (not $success)
                    {
                        die "benchmarkanything-storage: error while adding data to backend '".$c->{_balib}{backend}."': ".$@;
                    }
                }
                print "Done.\n" if $c->options->{verbose};
        }
        else
        {
                die "benchmarkanything-storage: backend ".$c->{_balib}{backend}." not yet implemented, available backends are: 'tapper'\n";
        }

        return;
}

sub _createdb
{
        my ($c) = @_;

        $c->{_balib}->connect->createdb;

        return;
}

__END__

=head1 ABOUT

Cmdline tool to handle BenchmarkAnything data, see
L<http://benchmarkanything.org|http://benchmarkanything.org>

=head1 SYNOPSIS

Default data format (in and out) is JSON, other formats can be
specified.

Add data to configured backend storage:

  $ benchmarkanything-storage add data.json

Query backend storage for data:

  $ echo 'json_search_query' | benchmarkanything-storage search -

Declare input format YAML:

  $ benchmarkanything-storage add -i yaml data.yaml

=head2 Input formats

The following B<input formats> are allowed, with their according
modules used to convert the input into a data structure:

 yaml   - YAML::Any (default)
 json   - JSON
 dumper - Data::Dumper (including the leading $VAR1 variable assignment)

=head1 SEE ALSO

For more information about the BenchmarkAnything schema, see
L<http://www.benchmarkanything.org/|http://www.benchmarkanything.org/>.

=cut
